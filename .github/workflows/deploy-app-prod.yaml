name: Deploy production from main branch

on:
  workflow_dispatch:
    inputs:
      image_version:
        description: "Version to deploy"
        required: true
        default: "latest"
        type: string
      branch_name:
        description: "Branch to deploy"
        required: true
        default: "main"
        type: string

  repository_dispatch:
    types: [deploy-prod]

env:
  NAME_PREFIX: "salko"
  SITE_PREFIX: "www"
  HOST_URL: "savonlinnanlentokerho.fi"

jobs:
  create-runner:
    name: Create Hetzner Cloud runner
    runs-on: ubuntu-24.04
    outputs:
      label: ${{ steps.create-hcloud-runner.outputs.label }}
      server_id: ${{ steps.create-hcloud-runner.outputs.server_id }}
    steps:
      - name: Create runner
        id: create-hcloud-runner
        uses: Cyclenerd/hcloud-github-runner@v1.3.0
        with:
          mode: create
          github_token: ${{ secrets.HETZNER_GHA_RUNNER_PAT }}
          hcloud_token: ${{ secrets.HETZNER_API_TOKEN }}
          network: ${{ secrets.HETZNER_NETWORK_ID }}
          ssh_key: ${{ secrets.HETZNER_GHA_RUNNER_SSH_KEY_ID }}
          server_type: cx23
          location: hel1
          image: ubuntu-24.04
          pre_runner_script: |
            set -ex
            echo "Configuring private network routing..."
            sleep 10
            PRIVATE_IFACE=$(ip -o addr show | grep "10.1.1." | awk '{print $2}' | head -n1)
            if [ -z "$PRIVATE_IFACE" ]; then
              echo "No private interface found in 10.1.1.0/24 subnet, skipping network configuration"
              exit 0
            fi
            PRIVATE_IP=$(ip -o -4 addr show $PRIVATE_IFACE | awk '{print $4}' | cut -d/ -f1)
            echo "Found interface $PRIVATE_IFACE with IP $PRIVATE_IP"
            cat > /etc/netplan/60-private-network.yaml <<'NETPLAN_EOF'
            network:
              version: 2
              renderer: networkd
              ethernets:
                PLACEHOLDER_IFACE:
                  dhcp4: false
                  dhcp6: false
                  accept-ra: false
                  addresses:
                    - PLACEHOLDER_IP/32
                  routes:
                    - to: 10.1.0.0/16
                      via: 10.1.0.1
                      on-link: true
                      metric: 100
                  nameservers:
                    addresses:
                      - 1.1.1.1
                      - 1.0.0.1
            NETPLAN_EOF
            sed -i "s/PLACEHOLDER_IFACE/$PRIVATE_IFACE/g" /etc/netplan/60-private-network.yaml
            sed -i "s|PLACEHOLDER_IP|$PRIVATE_IP|g" /etc/netplan/60-private-network.yaml
            netplan apply
            echo "Network configuration applied successfully"
            ip route show

  deploy:
    needs: create-runner
    runs-on: ${{ needs.create-runner.outputs.label }}
    environment: production
    permissions:
      contents: write
      packages: write

    steps:
      - name: Extract workflow dispatch inputs
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          echo "Extracting workflow dispatch inputs..."
          echo "BRANCH_NAME=${{ github.event.inputs.branch_name }}" >> $GITHUB_ENV
          echo "IMAGE_VERSION=${{ github.event.inputs.image_version }}" >> $GITHUB_ENV

          # Set IMAGE_TAG_NAME for workflow_dispatch
          repo_lowercase=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          if [[ "${{ github.event.inputs.branch_name }}" == "main" ]]; then
            echo "IMAGE_TAG_NAME=ghcr.io/${repo_lowercase}-nextjs" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG_NAME=ghcr.io/${repo_lowercase}-nextjs-${{ github.event.inputs.branch_name }}" >> $GITHUB_ENV
          fi
          echo "Inputs extracted successfully."

      - name: Extract repository dispatch payload
        if: ${{ github.event_name == 'repository_dispatch' }}
        run: |
          echo "Verifying repository dispatch payload..."
          if [ -z "${{ github.event.client_payload.branch_name }}" ] || [ -z "${{ github.event.client_payload.image_tag_name }}" ] || [ -z "${{ github.event.client_payload.image_version }}" ]; then
            echo "❌ Missing required payload fields. Ensure 'branch_name', 'image_tag_name', and 'image_version' are provided."
            exit 1
          fi

          echo "Extracting repository dispatch payload..."
          echo "BRANCH_NAME=${{ github.event.client_payload.branch_name }}" >> $GITHUB_ENV
          echo "IMAGE_TAG_NAME=${{ github.event.client_payload.image_tag_name }}" >> $GITHUB_ENV
          echo "IMAGE_VERSION=${{ github.event.client_payload.image_version }}" >> $GITHUB_ENV
          echo "Payload extracted successfully."

      - name: Checkout repository
        uses: actions/checkout@v4.2.2
        with:
          ref: ${{ github.event.inputs.branch_name || github.event.client_payload.branch_name || 'main' }}
          sparse-checkout: |
            docker-compose.prod.yaml
            postgres/init/

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ vars.SERVER_IP_SALKO0 }} >> ~/.ssh/known_hosts

      - name: Transfer configuration files to SERVER
        run: |
          echo "Transferring docker-compose.prod.yaml..."
          if ! scp -i ~/.ssh/id_ed25519 ./docker-compose.prod.yaml salko@${{ vars.SERVER_IP_SALKO0 }}:/home/salko/docker-compose.prod.yaml; then
            echo "Failed to transfer docker-compose.prod.yaml"
            exit 1
          fi

          echo "Creating postgres-prod directory if it doesn't exist..."
          if ! ssh -i ~/.ssh/id_ed25519 salko@${{ vars.SERVER_IP_SALKO0 }} "mkdir -p /home/salko/postgres-prod/init"; then
            echo "Failed to create directory"
            exit 1
          fi

          echo "Transferring postgres init scripts..."
          if ! scp -i ~/.ssh/id_ed25519 ./postgres/init/* salko@${{ vars.SERVER_IP_SALKO0 }}:/home/salko/postgres-prod/init/; then
            echo "Failed to transfer init scripts"
            exit 1
          fi

          echo "Adjusting permissions on transferred files..."
          if ! ssh -i ~/.ssh/id_ed25519 salko@${{ vars.SERVER_IP_SALKO0 }} "chmod -R 777 /home/salko/postgres-prod/init/*.sql"; then
            echo "Failed to adjust file permissions"
            exit 1
          fi

          echo "Verifying files were transferred correctly..."
          ssh -i ~/.ssh/id_ed25519 salko@${{ vars.SERVER_IP_SALKO0 }} "ls -la /home/salko/postgres-prod/init/"

      - name: Deploy APP to SERVER
        env:
          BRANCH_SUFFIX: "prod"
          NODE_ENV: "production"
          CONTAINER_PORT: "3000"
          HOST_PORT: "3000"
          HOSTNAME: "0.0.0.0"
          PGPORT: "5432"
          POSTGRES_USER: "salko_admin"
          POSTGRES_DB: "salko"
          APP_DB_USER: "salko_app"
          UMAMI_DB_USER: "umami_app"
          UMAMI_INTERNAL_URL: "http://salko-umami:3000"
          NEXTAUTH_URL: "https://${{ env.SITE_PREFIX }}.${{ env.HOST_URL }}"
        run: |
          echo "Deploying to production environment..."
          ssh -i ~/.ssh/id_ed25519 salko@${{ vars.SERVER_IP_SALKO0 }} << "EOF"
            # Create or clear the .env.prod file
            > .env.prod

            # Append environment variables one by one
            echo "NAME_PREFIX=${{ env.NAME_PREFIX }}" > .env.prod
            echo "SITE_PREFIX=${{ env.SITE_PREFIX }}" >> .env.prod
            echo "BRANCH_SUFFIX=${{ env.BRANCH_SUFFIX }}" >> .env.prod
            echo "NODE_ENV=${{ env.NODE_ENV }}" >> .env.prod
            echo "CONTAINER_PORT=${{ env.CONTAINER_PORT }}" >> .env.prod
            echo "HOST_PORT=${{ env.HOST_PORT }}" >> .env.prod
            echo "HOSTNAME=${{ env.HOSTNAME }}" >> .env.prod
            echo "HOST_URL=${{ env.HOST_URL }}" >> .env.prod
            echo "IMAGE_TAG_NAME=${{ env.IMAGE_TAG_NAME }}" >> .env.prod
            echo "IMAGE_VERSION=${{ env.IMAGE_VERSION }}" >> .env.prod
            echo "PGPORT=${{ env.PGPORT }}" >> .env.prod
            echo "POSTGRES_USER=${{ env.POSTGRES_USER }}" >> .env.prod
            echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env.prod
            echo "POSTGRES_DB=${{ env.POSTGRES_DB }}" >> .env.prod
            echo "APP_DB_USER=${{ env.APP_DB_USER }}" >> .env.prod
            echo "APP_DB_PASSWORD=${{ secrets.APP_DB_PASSWORD }}" >> .env.prod
            echo "PGTZ=UTC" >> .env.prod
            echo "NEXTAUTH_URL=${{ env.NEXTAUTH_URL }}" >> .env.prod
            echo "NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}" >> .env.prod
            echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env.prod
            echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" >> .env.prod
            echo "UMAMI_DB_USER=${{ env.UMAMI_DB_USER }}" >> .env.prod
            echo "UMAMI_DB_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env.prod
            echo "UMAMI_INTERNAL_URL=${{ env.UMAMI_INTERNAL_URL }}" >> .env.prod
            echo "NEXT_PUBLIC_UMAMI_WEBSITE_ID=${{ secrets.NEXT_PUBLIC_UMAMI_WEBSITE_ID }}" >> .env.prod

            # Ensure the environment variables are written before proceeding
            echo ".env.prod file created with environment variables."

            # Secure the .env.prod file permissions (readable only by owner)
            chmod 600 .env.prod
            echo "Secured .env.prod file permissions to 600."

            # Stop the current containers (keep data for production)
            echo "Stopping containers..."
            docker compose -p salko-prod --env-file .env.prod -f docker-compose.prod.yaml down

            # Start the containers using Docker Compose
            echo "Starting containers using Docker Compose..."
            docker compose -p salko-prod --env-file .env.prod -f docker-compose.prod.yaml up -d

            # Wait for services to start
            sleep 15

            # Verify the deployment
            echo "Verifying the deployment..."
            if docker ps | grep -q "salko-nextjs-${{ env.BRANCH_SUFFIX }}"; then
              echo "Deployment successful: salko-nextjs-${{ env.BRANCH_SUFFIX }} is running."
            else
              echo "Deployment failed: salko-nextjs-${{ env.BRANCH_SUFFIX }} is not running."
              docker ps
              exit 1
            fi

            echo "Cleaning up old images..."
            docker image prune -f

            echo "Deployment complete."
          EOF

      - name: Update monitoring secrets
        env:
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          UMAMI_APP_SECRET: ${{ secrets.UMAMI_APP_SECRET }}
        run: |
          echo "Updating monitoring secrets..."
          ssh -i ~/.ssh/id_ed25519 salko@${{ vars.SERVER_IP_SALKO0 }} << 'EOF'
            # Update .env.monitoring with prod secrets
            sed -i "s|^PROD_POSTGRES_EXPORTER_DSN=.*|PROD_POSTGRES_EXPORTER_DSN=postgresql://postgres:${{ env.POSTGRES_PASSWORD }}@salko-postgres-prod:5432/salko?sslmode=disable|" .env.monitoring || true
            sed -i "s|^DATABASE_URL=.*|DATABASE_URL=postgresql://umami_app:${{ env.POSTGRES_PASSWORD }}@salko-postgres-prod:5432/umami|" .env.monitoring || true
            sed -i "s|^APP_SECRET=.*|APP_SECRET=${{ env.UMAMI_APP_SECRET }}|" .env.monitoring || true
            echo "✅ Monitoring secrets updated"

            # Restart monitoring stack to apply new secrets
            echo "Restarting monitoring stack..."
            docker compose --env-file .env.monitoring -f docker-compose.monitoring.yaml restart || true
          EOF

      - name: Notify success
        if: ${{ success() }}
        run: |
          echo "✅ Deployment successful!"
          echo "Site is available at: https://${{ env.SITE_PREFIX }}.${{ env.HOST_URL }}"

      - name: Notify failure
        if: ${{ failure() }}
        run: |
          echo "❌ Deployment failed!"

      - name: Post Task Summary
        run: |
          {
            echo "## Deployment Summary"
            echo "- **Environment:** Production"
            echo "- **Branch:** \`${{ github.event.inputs.branch_name || github.event.client_payload.branch_name || 'main' }}\`"
            echo "- **Image Version:** \`${{ env.IMAGE_VERSION }}\`"
            echo "- **Image Tag:** \`${{ env.IMAGE_TAG_NAME }}\`"
            echo "- **Site URL:** [https://${{ env.SITE_PREFIX }}.${{ env.HOST_URL }}](https://${{ env.SITE_PREFIX }}.${{ env.HOST_URL }})"
            echo "- **Deployment Status:** \`${{ job.status }}\`"
            echo "- **Workflow:** ${{ github.workflow }}"
            echo "- **Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          } >> $GITHUB_STEP_SUMMARY

  delete-runner:
    name: Delete Hetzner Cloud runner
    needs:
      - create-runner
      - deploy
    runs-on: ubuntu-24.04
    if: ${{ always() }}
    steps:
      - name: Delete runner
        uses: Cyclenerd/hcloud-github-runner@v1.3.0
        with:
          mode: delete
          github_token: ${{ secrets.HETZNER_GHA_RUNNER_PAT }}
          hcloud_token: ${{ secrets.HETZNER_API_TOKEN }}
          name: ${{ needs.create-runner.outputs.label }}
          server_id: ${{ needs.create-runner.outputs.server_id }}
